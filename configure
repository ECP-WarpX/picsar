#! /usr/bin/python
"""
This file configures the installation of PICSAR in Python mode.

It reads the file Makefile_Forthon.in and creates a new file
Makefile_Forthon, where the MPI libraries and flags have been
set to the proper values for the current system.

Usage
-----
In a terminal, type `./configure` and then `make -f Makefile_Forthon`
"""
import os, subprocess, re, sys

# Get the name of the host
try:
    host = os.environ['HOST']
except KeyError:
    host = ''
print('')

# Read compiler and architecture from optional command-line arguments
fort_compiler = 'gnu'
set_architecture = None
if len(sys.argv) >= 2:
    fort_compiler = sys.argv[1]
    if fort_compiler not in ['gnu', 'intel']:
        print(fort_compiler + ' compiler not implemented. Back to default: gnu.')
        fort_compiler = 'gnu'
if len(sys.argv) >= 3:
    set_architecture = sys.argv[2]
    if set_architecture not in ['knl']:
        print(set_architecture + ' architecture not implemented. Back to default.')
        set_architecture = None

# Check if we are on Edison, on NERSC
if host.startswith('edison') or host.startswith('cori'):
    print('Configuring PICSAR on Edison/Cori')
    comp = 'ftn'
    libdir_list = []
    if fort_compiler == 'gnu':
        fcomp = 'gfortran'
        libs = '-lgomp'
        if set_architecture == 'knl':
            fargs = '"-O3 -fopenmp -march=knl -ffree-line-length-none -ftree-vectorize -ftree-vectorizer-verbose=0"'
        else:
            fargs = '"-O3 -fopenmp -ffree-line-length-none -ftree-vectorize -ftree-vectorizer-verbose=0"'
    elif fort_compiler == 'intel':
        fcomp = 'intel'
        libs = ''
        if set_architecture == 'knl':
            fargs = '"-O3 -qopenmp  -xMIC-AVX512"'
        else:
            fargs = '"-O3 -qopenmp -xCORE-AVX2 -align array64byte"'
    parsed_mpi = True
else:
    comp = 'mpif90'
    # Parse the result of mpif90 -show
    parsed_mpi = True   # By default ; errors modify this flag
    try:
        info = subprocess.check_output( [ 'mpif90', '-show' ] )
    except OSError:
        print('** Failed to detect mpif90 on your system. Is it installed?')
        parsed_mpi = False
        libdir_list = []
        libs = ''
    else:
        # Find the library path, using regular expressions
        libdir_list = re.findall('\s-L(\S+)', info)
        if libdir_list == []:
            print('** Failed to detect MPI library location on your system.')
            parsed_mpi = False
        else:
            print('MPI library: %s' %(', '.join(libdir_list)) )

        # Find the proper flags, using regular expressions
        flag_list = re.findall('\s-l(\S+)', info)
        if flag_list == []:
            print('** Failed to detect MPI flags on your system.')
            parsed_mpi = False
            libs = ''
        else:
            libs = ' '.join([ '-l%s' %flag for flag in flag_list ])
            libs += ' -lgomp'
            print('MPI flags: %s' %libs)

# Read the file Makefile_Forthon.in
with open('Makefile_Forthon.in') as f:
    makefile_text = f.read()

# Replace the libraries in the text
if libdir_list != []:
    makefile_text = makefile_text.replace(
    'LIBDIR=', 'LIBDIR=-L%s' %(' -L'.join(libdir_list) ) )

makefile_text = re.sub('\nLIBS=.*', '\nLIBS=%s' %libs, makefile_text)
makefile_text = re.sub('\nFCOMPEXEC=.*', '\nFCOMPEXEC=%s' %comp, makefile_text)
makefile_text = re.sub('\nFCOMP=.*', '\nFCOMP=%s' %fcomp, makefile_text)
makefile_text = re.sub('\nFARGS=.*', '\nFARGS=%s' %fargs, makefile_text)

# Write the new file Makefile_Forthon
with open('Makefile_Forthon', 'w') as f:
    f.write( makefile_text )

# Print messages if the configure failed
if parsed_mpi == False:
    print('\n** Configure failed.')
    print('Modify the Makefile_Forthon by hand, to set LIBDIR and LIBS\n')
    sys.exit(1)
else:
    print('\nConfigure succeeded.')
    print('To compile PICSAR in Python mode, type `make -f Makefile_Forthon`\n')
    if host.startswith('edison') or host.startswith('cori'):
        print('(Please make sure your PrgEnv- module is consistant with your ./configure options)')
    sys.exit(0)
